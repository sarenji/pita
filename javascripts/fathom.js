// Generated by CoffeeScript 1.3.3
(function() {
  var Bar, BasicHooks, Camera, Color, Entities, Entity, FollowBar, FollowCam, Key, Map, Optional, Pixel, Point, Rect, StaticImage, Text, TextBox, Tick, Tile, Util, Vector, World, assert, canvas, context, currentWorld, entities, fixedInterval, getCamera, getFPS, getUniqueID, initialize, loadImage, mousePick, ready, setWorld, temp_context, types, uniqueID, _ref,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = (typeof window === 'undefined' ? (require("./types")).Types : this.Types), Optional = _ref.Optional, types = _ref.types;

  Util = (function() {

    function Util() {}

    Util.sign = function(n) {
      if (n > 0) {
        return 1;
      } else if (n < 0) {
        return -1;
      } else {
        return 0;
      }
    };

    Util.arraysEqual = function(a, b) {
      return !!a && !!b && !(a < b || b < a);
    };

    Util.movementVector = function() {
      var x, y;
      x = Key.isDown(Key.Right) - Key.isDown(Key.Left);
      y = Key.isDown(Key.Down) - Key.isDown(Key.Up);
      return new Vector(x, y);
    };

    Util.epsilonEq = function(a, b, threshold) {
      return Math.abs(a - b) < threshold;
    };

    Util.randRange = function(low, high) {
      return low + Math.floor(Math.random() * (high - low));
    };

    Util.randElem = function(arr) {
      return arr[Util.randRange(0, arr.length)];
    };

    return Util;

  })();

  Color = (function() {

    function Color(r, g, b) {
      this.r = r != null ? r : 0;
      this.g = g != null ? g : 0;
      this.b = b != null ? b : 0;
    }

    Color.prototype.toString = function() {
      return "#" + (this.r.toString(16)[0]) + (this.g.toString(16)[0]) + (this.b.toString(16)[0]);
    };

    Color.prototype.randomizeRed = function(low, high) {
      if (low == null) {
        low = 0;
      }
      if (high == null) {
        high = 255;
      }
      this.r = Util.randRange(low, high);
      return this;
    };

    Color.prototype.randomizeGreen = function(low, high) {
      if (low == null) {
        low = 0;
      }
      if (high == null) {
        high = 255;
      }
      this.g = Util.randRange(low, high);
      return this;
    };

    Color.prototype.randomizeBlue = function(low, high) {
      if (low == null) {
        low = 0;
      }
      if (high == null) {
        high = 255;
      }
      this.b = Util.randRange(low, high);
      return this;
    };

    return Color;

  })();

  Tick = (function() {

    function Tick() {}

    Tick.ticks = 0;

    return Tick;

  })();

  Point = (function() {

    function Point(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      types(Optional(Number), Optional(Number));
    }

    Point.prototype.setPosition = function(p) {
      types(Point);
      this.x = p.x;
      return this.y = p.y;
    };

    Point.prototype.clone = function() {
      return new Point(this.x, this.y);
    };

    Point.prototype.toRect = function(width, height) {
      if (height == null) {
        height = width;
      }
      types(Number, Optional(Number));
      return new Rect(this.x, this.y, width, height);
    };

    Point.prototype.point = function() {
      return new Point(this.x, this.y);
    };

    Point.prototype.eq = function(p) {
      types(Point);
      return Util.epsilonEq(this.x, p.x) && Util.epsilonEq(this.y, p.y);
    };

    Point.prototype.close = function(p, threshold) {
      if (threshold == null) {
        threshold = 1;
      }
      types(Point, Optional(Number));
      return Util.epsilonEq(this.x, p.x, threshold) && Util.epsilonEq(this.y, p.y, threshold);
    };

    Point.prototype.add = function(v) {
      types(Vector);
      this.x += v.x;
      this.y += v.y;
      return this;
    };

    Point.prototype.offscreen = function(screen) {
      types(Rect);
      return !screen.touchingPoint(this);
    };

    Point.prototype.subtract = function(p) {
      types(Point);
      return new Vector(this.x - p.x, this.y - p.y);
    };

    return Point;

  })();

  Vector = (function() {

    function Vector(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      types(Optional(Number), Optional(Number));
    }

    Vector.prototype.eq = function(v) {
      types(Vector);
      return this.x === v.x && this.y === v.y;
    };

    Vector.prototype.randomize = function() {
      var r;
      r = Math.floor(Math.random() * 4);
      if (r === 0) {
        this.x = 0;
        this.y = 1;
      }
      if (r === 1) {
        this.x = 0;
        this.y = -1;
      }
      if (r === 2) {
        this.x = 1;
        this.y = 0;
      }
      if (r === 3) {
        this.x = -1;
        this.y = 0;
      }
      return this;
    };

    Vector.prototype.multiply = function(n) {
      types(Number);
      this.x *= n;
      this.y *= n;
      return this;
    };

    Vector.prototype.divide = function(n) {
      types(Number);
      this.x /= n;
      this.y /= n;
      return this;
    };

    Vector.prototype.add = function(v) {
      types(Vector);
      this.x += v.x;
      this.y += v.y;
      return this;
    };

    Vector.prototype.normalize = function() {
      var mag;
      mag = Math.sqrt(this.x * this.x + this.y * this.y);
      this.x /= mag;
      this.y /= mag;
      return this;
    };

    Vector.prototype.nonzero = function() {
      return this.x !== 0 || this.y !== 0;
    };

    return Vector;

  })();

  Key = (function() {

    function Key() {}

    Key.getCode = function(e) {
      var code;
      if (!e) {
        e = window.event;
      }
      if (e.keyCode) {
        code = e.keyCode;
      } else if (e.which) {
        code = e.which;
      }
      return code;
    };

    Key.addKeys = function() {
      var alphabet, chr, i, _i, _len;
      alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      for (i = _i = 0, _len = alphabet.length; _i < _len; i = ++_i) {
        chr = alphabet[i];
        this[chr] = alphabet.charCodeAt(i);
      }
      this.Left = 37;
      this.Up = 38;
      this.Right = 39;
      return this.Down = 40;
    };

    Key.start = function(addListeners) {
      var x,
        _this = this;
      if (addListeners == null) {
        addListeners = true;
      }
      types(Optional(Boolean));
      this.addKeys();
      this.keysDown = (function() {
        var _i, _results;
        _results = [];
        for (x = _i = 0; _i <= 255; x = ++_i) {
          _results.push(false);
        }
        return _results;
      })();
      if (addListeners) {
        document.onkeydown = function(e) {
          var _ref1;
          _this.keysDown[_this.getCode(e)] = true;
          if ((_ref1 = _this.getCode(e)) === _this.Left || _ref1 === _this.Up || _ref1 === _this.Right || _ref1 === _this.Down) {
            return e.preventDefault();
          }
        };
        return document.onkeyup = function(e) {
          var _ref1;
          _this.keysDown[_this.getCode(e)] = false;
          if ((_ref1 = _this.getCode(e)) === _this.Left || _ref1 === _this.Up || _ref1 === _this.Right || _ref1 === _this.Down) {
            return e.preventDefault();
          }
        };
      }
    };

    Key.isDown = function(key) {
      types(Number);
      return this.keysDown[key];
    };

    Key.isUp = function(key) {
      types(Number);
      if (this.keysDown[key]) {
        this.keysDown[key] = false;
        return true;
      } else {
        return false;
      }
    };

    Key.flush = function() {
      return this.start(false);
    };

    return Key;

  })();

  BasicHooks = (function() {

    function BasicHooks() {}

    BasicHooks.stickTo = function(stuckTo, dx, dy) {
      if (dx == null) {
        dx = 0;
      }
      if (dy == null) {
        dy = 0;
      }
      return function() {
        return this.setPosition(stuckTo.clone().add(new Vector(dx, dy)));
      };
    };

    BasicHooks.slideTo = function(slideTo, speed) {
      if (speed == null) {
        speed = 20;
      }
      return function() {
        return this.add(slideTo.subtract(this).divide(speed));
      };
    };

    BasicHooks.rpgLike = function(speed) {
      types(Number);
      return function() {
        var v;
        v = Util.movementVector().multiply(speed);
        this.vx += v.x;
        this.vy += v.y;
        this.x += this.vx;
        return this.y += this.vy;
      };
    };

    BasicHooks.resolveCollisions = function() {
      return function() {
        var _this = this;
        if (this.__fathom.entities.any(function(other) {
          return other.collides(_this);
        })) {
          this.x -= this.vx;
          this.vx = 0;
        }
        if (this.__fathom.entities.any(function(other) {
          return other.collides(_this);
        })) {
          this.y -= this.vy;
          return this.vy = 0;
        }
      };
    };

    BasicHooks.decel = function() {
      var cutoff, decel;
      cutoff = .5;
      decel = 2;
      return function() {
        if (Math.abs(this.vx) < cutoff) {
          this.vx = 0;
        }
        if (Math.abs(this.vy) < cutoff) {
          this.vy = 0;
        }
        this.vx /= decel;
        return this.vy /= decel;
      };
    };

    BasicHooks.move = function(direction) {
      types(Vector);
      return function() {
        return this.add(direction);
      };
    };

    BasicHooks.onCollide = function(type, cb) {
      types(String, Function);
      return function() {
        var collision,
          _this = this;
        collision = this.__fathom.entities.one(type, function(other) {
          return other.collides(_this);
        });
        if (collision) {
          return cb.bind(this)(collision);
        }
      };
    };

    BasicHooks.onLeaveMap = function(object, map, cb) {
      return function() {
        if (object.x <= 0 || object.y <= 0 || object.x >= map.width || object.y >= map.height) {
          return cb.bind(object)();
        }
      };
    };

    BasicHooks.platformerLike = function(speed, object) {
      var onGround;
      types(Number, Entity, Entities);
      object.vx += (Key.isDown(Key.D) - Key.isDown(Key.A)) * speed;
      object.vy += 5;
      if (Key.isDown(Key.W)) {
        onGround = object.__fathom.entities.any(function(other) {
          return other.collides(this);
        });
        if (onGround) {
          return object.vy -= 50;
        }
      }
    };

    return BasicHooks;

  }).call(this);

  assert = function(fn) {
    if (!fn()) {
      throw new Error("AssertionError");
    }
  };

  uniqueID = 0;

  getUniqueID = function() {
    return uniqueID++;
  };

  Entities = (function() {

    function Entities() {
      this.entities = [];
      this.entityInfo = [];
    }

    Entities.prototype.add = function(entity) {
      types(Entity);
      return this.entities.push(entity);
    };

    Entities.prototype.get = function() {
      var criteria, entity, item, pass, remainingEntities, _i, _j, _len, _len1, _ref1;
      criteria = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      remainingEntities = this.entities;
      for (_i = 0, _len = criteria.length; _i < _len; _i++) {
        item = criteria[_i];
        pass = [];
        for (_j = 0, _len1 = remainingEntities.length; _j < _len1; _j++) {
          entity = remainingEntities[_j];
          switch (typeof item) {
            case "string":
              if (item[0] === "!") {
                if (_ref1 = item.slice(1), __indexOf.call(entity.groups(), _ref1) < 0) {
                  pass.push(entity);
                }
              } else {
                if (__indexOf.call(entity.groups(), item) >= 0) {
                  pass.push(entity);
                }
              }
              break;
            case "function":
              if (item(entity)) {
                pass.push(entity);
              }
              break;
            default:
              throw new Error("UnsupportedCriteriaType " + (typeof item));
          }
        }
        remainingEntities = pass;
      }
      return remainingEntities;
    };

    Entities.prototype.one = function() {
      var criteria, results;
      criteria = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      results = this.get.apply(this, criteria);
      if (results.length) {
        return results[0];
      } else {
        return null;
      }
    };

    Entities.prototype.any = function() {
      var criteria;
      criteria = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (this.get.apply(this, criteria)).length > 0;
    };

    Entities.prototype.can = function(decorator) {
      return decorator.call(this);
    };

    Entities.prototype.remove = function(entity) {
      var e, uid;
      uid = entity.__fathom.uid;
      return this.entities = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.entities;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          e = _ref1[_i];
          if (e.__fathom.uid !== uid) {
            _results.push(e);
          }
        }
        return _results;
      }).call(this);
    };

    Entities.prototype.getEntity = function(groups) {
      var result;
      types(Object);
      result = this.get(groups);
      assert(function() {
        return result.length === 1;
      });
      return result[0];
    };

    Entities.prototype.render = function(context) {
      var entities, entity, _i, _len, _results;
      entities = this.get("renderable");
      entities.sort(function(a, b) {
        return a.depth() - b.depth();
      });
      _results = [];
      for (_i = 0, _len = entities.length; _i < _len; _i++) {
        entity = entities[_i];
        entity.emit("pre-render");
        entity.render(context);
        _results.push(entity.emit("post-render"));
      }
      return _results;
    };

    Entities.prototype.update = function(entities) {
      var entity, _i, _len, _ref1, _results;
      types(Entities);
      _ref1 = this.get("updateable");
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        entity = _ref1[_i];
        entity.emit("pre-update");
        entity.update(entities);
        _results.push(entity.emit("post-update"));
      }
      return _results;
    };

    return Entities;

  })();

  entities = new Entities;

  Rect = (function(_super) {

    __extends(Rect, _super);

    function Rect(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height != null ? height : this.width;
      types(Number, Number, Number, Optional(Number));
      Rect.__super__.constructor.call(this, this.x, this.y);
      this.right = this.x + this.width;
      this.bottom = this.y + this.height;
    }

    Rect.prototype.touchingRect = function(rect) {
      types(Rect);
      return !(rect.x > this.x + this.width || rect.x + rect.width < this.x || rect.y > this.y + this.height || rect.y + rect.height < this.y);
    };

    Rect.prototype.touchingPoint = function(point) {
      var _ref1, _ref2;
      types(Point);
      return (this.x <= (_ref1 = point.x) && _ref1 <= this.x + this.width) && (this.y <= (_ref2 = point.y) && _ref2 <= this.y + this.height);
    };

    return Rect;

  })(Point);

  World = (function() {

    function World() {
      this.entities = [];
    }

    World.prototype.add = function(entity) {
      types(Entity);
      return this.entities.push(entity);
    };

    World.prototype.remove = function(entityToRemove) {
      var entity, i, _i, _len, _ref1, _results;
      _ref1 = this.entities;
      _results = [];
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        entity = _ref1[i];
        if (entity === entityToRemove) {
          this.entities.splice(i, 1);
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return World;

  })();

  currentWorld = null;

  setWorld = function(world) {
    types(World);
    return currentWorld = world;
  };

  Entity = (function(_super) {

    __extends(Entity, _super);

    function Entity(x, y, width, height, color) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      this.width = width != null ? width : 20;
      this.height = height != null ? height : this.width;
      this.color = color != null ? color : "#000";
      types(Optional(Number), Optional(Number), Optional(Number), Optional(Number), Optional(String));
      Entity.__super__.constructor.call(this, this.x, this.y, this.width, this.height);
      this.__fathom = {
        uid: getUniqueID(),
        events: {},
        entities: entities
      };
      entities.add(this);
    }

    Entity.prototype.entities = function() {
      return this.__fathom.entities;
    };

    Entity.prototype.on = function(event, callback) {
      var chain;
      types(String, Function);
      this.__fathom.events[event] = chain = this.__fathom.events[event] || [];
      if (__indexOf.call(chain, callback) < 0) {
        chain.push(callback);
      }
      return this;
    };

    Entity.prototype.off = function(event, callback) {
      var hook;
      if (callback == null) {
        callback = null;
      }
      types(String, Optional(Function));
      if (callback) {
        if (this.__fathom.events[event]) {
          this.__fathom.events[event] = (function() {
            var _i, _len, _ref1, _results;
            _ref1 = this.__fathom.events[event];
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              hook = _ref1[_i];
              if (hook !== callback) {
                _results.push(hook);
              }
            }
            return _results;
          }).call(this);
          if (this.__fathom.events[event].length === 0) {
            delete this.__fathom.events[event];
          }
        } else {
          throw new Error("Entity#off called on an event that the entity did not have.");
        }
      } else if (event) {
        if (this.__fathom.events[event]) {
          delete this.__fathom.events[event];
        } else {
          throw new Error("Entity#off called on an event that the entity did not have.");
        }
      }
      return this;
    };

    Entity.prototype.emit = function() {
      var args, event, hook, _i, _len, _ref1;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (event in this.__fathom.events) {
        _ref1 = this.__fathom.events[event];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          hook = _ref1[_i];
          hook.bind(this).call(this);
        }
      }
      return this;
    };

    Entity.prototype.die = function() {
      return this.__fathom.entities.remove(this);
    };

    Entity.prototype.groups = function() {
      return ["renderable", "updateable"];
    };

    Entity.prototype.render = function(context) {
      context.fillStyle = this.color;
      return context.fillRect(this.x, this.y, this.width, this.height);
    };

    Entity.prototype.collides = function(other) {
      types(Entity);
      return this.__fathom.uid !== other.__fathom.uid && this.touchingRect(other);
    };

    Entity.prototype.update = function() {};

    Entity.prototype.depth = function() {
      return 0;
    };

    return Entity;

  })(Rect);

  Tile = (function(_super) {

    __extends(Tile, _super);

    function Tile(x, y, width, type) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.type = type;
      Tile.__super__.constructor.call(this, this.x, this.y, this.width);
      types(Number, Number, Number, Number);
      if (this.type === 0) {
        this.color = new Color().randomizeRed(150, 255).toString();
      } else if (this.type === 1) {
        this.color = "#ff0";
      }
    }

    Tile.prototype.render = function(context, dx, dy) {
      context.fillStyle = this.color;
      return context.fillRect(this.x + dx, this.y + dy, this.width, this.height);
    };

    return Tile;

  })(Rect);

  Bar = (function(_super) {

    __extends(Bar, _super);

    function Bar(x, y, width, fillColor, emptyColor) {
      this.x = x;
      this.y = y;
      this.width = width != null ? width : 50;
      this.fillColor = fillColor != null ? fillColor : "#0f0";
      this.emptyColor = emptyColor != null ? emptyColor : "#f00";
      types(Number, Number, Optional(Number), Optional(String), Optional(String));
      this.borderColor = "#000";
      this.borderWidth = 1;
      this.height = 10;
      this.amt = 50;
      this.total = 100;
      Bar.__super__.constructor.call(this, this.x, this.y, this.width, this.height);
    }

    Bar.prototype.groups = function() {
      return ["renderable", "updateable", "bar"];
    };

    Bar.prototype.collides = function() {
      return false;
    };

    Bar.prototype.update = function() {};

    Bar.prototype.render = function(context) {
      var coloredWidth;
      context.fillStyle = this.borderColor;
      context.fillRect(this.x, this.y, this.width, this.height);
      context.fillStyle = this.emptyColor;
      context.fillRect(this.x + this.borderWidth, this.y + this.borderWidth, this.width - this.borderWidth * 2, this.height - this.borderWidth * 2);
      coloredWidth = (this.amt / this.total) * (this.width - 2);
      context.fillStyle = this.fillColor;
      return context.fillRect(this.x + this.borderWidth, this.y + this.borderWidth, coloredWidth, this.height - this.borderWidth * 2);
    };

    return Bar;

  })(Entity);

  FollowBar = (function(_super) {

    __extends(FollowBar, _super);

    function FollowBar() {
      var follow, rest;
      follow = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this.follow = follow;
      FollowBar.__super__.constructor.apply(this, rest);
      this.on("pre-update", Fathom.BasicHooks.stickTo(this.follow, 0, -10));
    }

    return FollowBar;

  })(Bar);

  Pixel = (function() {

    function Pixel(r, g, b, a) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
      types(Number, Number, Number, Number);
    }

    Pixel.prototype.eq = function(p) {
      types(Pixel);
      return this.r === p.r && this.g === p.g && this.b === p.b && (this.a = p.a);
    };

    return Pixel;

  })();

  loadImage = function(loc, callback) {
    var img;
    img = document.createElement('img');
    img.onload = function() {
      var data, pixels, x, y, z, _i, _j, _ref1, _ref2;
      temp_context.drawImage(img, 0, 0);
      data = temp_context.getImageData(0, 0, img.width, img.height).data;
      pixels = (function() {
        var _i, _ref1, _results;
        _results = [];
        for (x = _i = 0, _ref1 = img.width; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; x = 0 <= _ref1 ? ++_i : --_i) {
          _results.push([]);
        }
        return _results;
      })();
      for (x = _i = 0, _ref1 = img.width; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; x = 0 <= _ref1 ? ++_i : --_i) {
        for (y = _j = 0, _ref2 = img.height; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; y = 0 <= _ref2 ? ++_j : --_j) {
          z = (x * img.width + y) * 4;
          pixels[y][x] = new Pixel(data[z], data[z + 1], data[z + 2], data[z + 3]);
        }
      }
      return callback(pixels);
    };
    return img.src = loc;
  };

  Map = (function(_super) {

    __extends(Map, _super);

    function Map(widthInTiles, heightInTiles, tileSize) {
      var a, b;
      this.widthInTiles = widthInTiles;
      this.heightInTiles = heightInTiles;
      this.tileSize = tileSize;
      this.setTile = __bind(this.setTile, this);

      types(Number, Number, Number);
      Map.__super__.constructor.call(this, 0, 0, this.widthInTiles * this.tileSize, this.heightInTiles * this.tileSize);
      this.tiles = (function() {
        var _i, _ref1, _results;
        _results = [];
        for (a = _i = 0, _ref1 = this.widthInTiles; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; a = 0 <= _ref1 ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref2, _results1;
            _results1 = [];
            for (b = _j = 0, _ref2 = this.heightInTiles; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; b = 0 <= _ref2 ? ++_j : --_j) {
              _results1.push(null);
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
      this.data = void 0;
      this.corner = new Point(0, 0);
    }

    Map.prototype.setTile = function(x, y, type) {
      types(Number, Number, Number);
      return this.tiles[x][y] = new Tile(x * this.tileSize, y * this.tileSize, this.tileSize, type);
    };

    Map.prototype.setCorner = function(diff) {
      var val, x, y, _i, _ref1, _results;
      types(Vector);
      this.corner.add(diff.multiply(this.widthInTiles));
      _results = [];
      for (x = _i = 0, _ref1 = this.widthInTiles; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; x = 0 <= _ref1 ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref2, _results1;
          _results1 = [];
          for (y = _j = 0, _ref2 = this.heightInTiles; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; y = 0 <= _ref2 ? ++_j : --_j) {
            if (this.data[this.corner.x + x][this.corner.y + y].eq(new Pixel(0, 0, 0, 255))) {
              val = 1;
            } else {
              val = 0;
            }
            _results1.push(this.setTile(x, y, val));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Map.prototype.fromImage = function(loc, corner, callback) {
      var _this = this;
      types(String, Vector, Function);
      return ready(function() {
        if (_this.data) {
          _this.setCorner(corner);
          return;
        }
        return loadImage(loc, function(data) {
          _this.data = data;
          _this.setCorner(corner);
          return callback();
        });
      });
    };

    Map.prototype.groups = function() {
      return ["renderable", "wall", "map"];
    };

    Map.prototype.collides = function(other) {
      var x, xStart, y, yStart, _i, _j, _ref1, _ref2;
      types(Rect);
      xStart = Math.floor(other.x / this.tileSize);
      yStart = Math.floor(other.y / this.tileSize);
      for (x = _i = xStart, _ref1 = xStart + 2; xStart <= _ref1 ? _i <= _ref1 : _i >= _ref1; x = xStart <= _ref1 ? ++_i : --_i) {
        for (y = _j = yStart, _ref2 = yStart + 2; yStart <= _ref2 ? _j <= _ref2 : _j >= _ref2; y = yStart <= _ref2 ? ++_j : --_j) {
          if ((0 <= x && x < this.widthInTiles) && (0 <= y && y < this.heightInTiles)) {
            if (this.tiles[x][y].type === 1 && this.tiles[x][y].touchingRect(other)) {
              return true;
            }
          }
        }
      }
      return false;
    };

    Map.prototype.render = function(context) {
      var tileX, tileY, _i, _ref1, _results;
      _results = [];
      for (tileX = _i = 0, _ref1 = this.widthInTiles; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; tileX = 0 <= _ref1 ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref2, _results1;
          _results1 = [];
          for (tileY = _j = 0, _ref2 = this.heightInTiles; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; tileY = 0 <= _ref2 ? ++_j : --_j) {
            _results1.push(this.tiles[tileX][tileY].render(context, this.x, this.y));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return Map;

  })(Entity);

  StaticImage = (function(_super) {

    __extends(StaticImage, _super);

    function StaticImage(source, destination) {
      StaticImage.__super__.constructor.call(this, destination.x, destination.y, destination.size);
    }

    return StaticImage;

  })(Entity);

  Text = (function(_super) {

    __extends(Text, _super);

    function Text(text, x, y, opts) {
      var setup,
        _this = this;
      this.text = text;
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (opts == null) {
        opts = {};
      }
      types(String, Optional(Number), Optional(Number), Optional(Object));
      Text.__super__.constructor.call(this, x, y);
      this.color = opts.color || "#000000";
      this.baseline = opts.baseline || "top";
      this.size = opts.size || 16;
      this.font = opts.font || ("" + this.size + "px Courier New");
      setup = function() {
        context.fillStyle = _this.color;
        context.font = _this.font;
        return context.textBaseline = _this.baseline;
      };
      this.on('pre-update', setup);
      this.on('pre-render', setup);
    }

    Text.prototype.groups = function() {
      return ["renderable"];
    };

    Text.prototype.render = function(context) {
      return context.fillText(this.text, this.x, this.y);
    };

    Text.prototype.depth = function() {
      return 2;
    };

    Text.prototype.collides = function() {
      return false;
    };

    return Text;

  })(Entity);

  Camera = (function(_super) {

    __extends(Camera, _super);

    function Camera() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.dontAdjust = true;
      Camera.__super__.constructor.apply(this, args);
    }

    Camera.prototype.move = function(x, y) {
      this.x = x;
      return this.y = y;
    };

    Camera.prototype.groups = function() {
      return ["camera"];
    };

    Camera.prototype.collides = function() {
      return false;
    };

    Camera.prototype.render = function(entities, context, fn) {
      var e, _i, _j, _len, _len1, _ref1, _ref2, _results;
      _ref1 = entities.get();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        e = _ref1[_i];
        if (!(!e.dontAdjust)) {
          continue;
        }
        e.x -= this.x;
        e.y -= this.y;
      }
      entities.render(context);
      _ref2 = entities.get();
      _results = [];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        e = _ref2[_j];
        if (!(!e.dontAdjust)) {
          continue;
        }
        e.x += this.x;
        _results.push(e.y += this.y);
      }
      return _results;
    };

    return Camera;

  })(Entity);

  FollowCam = (function(_super) {

    __extends(FollowCam, _super);

    function FollowCam() {
      var follow, rest;
      follow = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this.follow = follow;
      FollowCam.__super__.constructor.apply(this, rest);
    }

    FollowCam.prototype.update = function() {
      return Fathom.BasicHooks.slideTo(new Point(this.follow.x - this.width / 2, this.follow.y - this.height / 2)).bind(this)();
    };

    FollowCam.prototype.groups = function() {
      return ["camera", "updateable"];
    };

    FollowCam.prototype.snap = function() {
      this.x = this.follow.x - this.width / 2;
      return this.y = this.follow.y - this.height / 2;
    };

    return FollowCam;

  })(Camera);

  TextBox = (function(_super) {

    __extends(TextBox, _super);

    function TextBox(text, x, y, width, height, opts) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      this.width = width != null ? width : 100;
      this.height = height != null ? height : -1;
      if (opts == null) {
        opts = {};
      }
      types(String, Number, Number, Optional(Number), Optional(Number), Optional(Object));
      TextBox.__super__.constructor.call(this, text, x, y, opts);
    }

    TextBox.prototype.groups = function() {
      return ["renderable", "updateable"];
    };

    TextBox.prototype.update = function() {
      var currentPhrase, oldPhrase, phrases, word, words, _i, _len;
      words = this.text.split(' ');
      phrases = [];
      currentPhrase = words.shift();
      oldPhrase = "";
      for (_i = 0, _len = words.length; _i < _len; _i++) {
        word = words[_i];
        oldPhrase = currentPhrase;
        currentPhrase += " " + word;
        if (context.measureText(currentPhrase).width > this.width) {
          currentPhrase = word;
          phrases.push(oldPhrase);
          oldPhrase = "";
        }
      }
      phrases.push(currentPhrase);
      return this.phrases = phrases;
    };

    TextBox.prototype.render = function(context) {
      var i, phrase, _i, _len, _ref1, _results;
      _ref1 = this.phrases;
      _results = [];
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        phrase = _ref1[i];
        _results.push(context.fillText(phrase, this.x, this.y + this.size * i));
      }
      return _results;
    };

    return TextBox;

  })(Text);

  canvas = null;

  context = null;

  temp_context = null;

  ready = function(callback) {
    var canv;
    types(Function);
    if (document.body) {
      if (!(temp_context != null)) {
        canv = document.createElement("canvas");
        canv.width = canv.height = 500;
        temp_context = canv.getContext('2d');
      }
      return callback();
    } else {
      return setTimeout((function() {
        return ready(callback);
      }), 250);
    }
  };

  fixedInterval = function(fn, fps) {
    if (fps == null) {
      fps = 24;
    }
    types(Function, Optional(Number));
    return setInterval(fn, 1000 / fps);
  };

  getFPS = function() {
    var now, thisFrameFPS;
    now = +new Date();
    thisFrameFPS = 1000 / (now - getFPS.lastUpdate);
    getFPS.fps += (thisFrameFPS - getFPS.fps) / getFPS.fpsFilter;
    getFPS.lastUpdate = now;
    return getFPS.fps;
  };

  getFPS.fpsFilter = 20;

  getFPS.lastUpdate = +new Date();

  getFPS.fps = 0;

  getCamera = function() {
    var cam;
    cam = entities.get("camera");
    if (cam.length > 1) {
      throw new Error("More than one camera.");
    }
    if (cam.length === 1) {
      cam = cam[0];
    }
    return cam;
  };

  initialize = function(gameLoop, canvasID) {
    var window_size;
    types(Function, String);
    window_size = 500;
    return ready(function() {
      var cam, wrappedLoop;
      Key.start();
      canvas = document.getElementById(canvasID);
      context = canvas.getContext('2d');
      cam = getCamera();
      wrappedLoop = function() {
        gameLoop(context);
        Tick.ticks += 1;
        entities.update(entities);
        context.fillStyle = "#fff";
        context.fillRect(0, 0, 500, 500);
        if (cam) {
          return cam.render(entities, context);
        } else {
          return entities.render(context);
        }
      };
      return fixedInterval(wrappedLoop);
    });
  };

  mousePick = function(x, y) {
    var cam, canv_offset, mousePos, underMouse;
    cam = entities.one("camera");
    canv_offset = $(canvas).parent().offset();
    x += cam.x - canv_offset.left;
    y += cam.y - canv_offset.top;
    mousePos = new Point(x, y);
    return underMouse = entities.get("!camera", "!map", function(o) {
      return o.touchingPoint(mousePos);
    });
  };

  this.Fathom = {
    Util: Util,
    Key: Key,
    Entity: Entity,
    Entities: Entities,
    Color: Color,
    Camera: Camera,
    FollowCam: FollowCam,
    mousePick: mousePick,
    BasicHooks: BasicHooks,
    Text: Text,
    Rect: Rect,
    Bar: Bar,
    FollowBar: FollowBar,
    TextBox: TextBox,
    Map: Map,
    Point: Point,
    Vector: Vector,
    initialize: initialize,
    getFPS: getFPS,
    Tick: Tick,
    World: World,
    setWorld: setWorld
  };

}).call(this);
